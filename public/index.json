[
{
	"uri": "/",
	"title": "Gloo Platform EKS Workshop",
	"tags": [],
	"description": "",
	"content": "Gloo Platform EKS Workshop Welcome Gloo Platform integrates API gateway, API management, Kubernetes Ingress, Istio service mesh and cloud-native networking into a unified application networking platform. It also simplifies multi-cluster management of service mesh for containers and virtual machines.\nIts modular component architecture allows it to scale across multiple clusters, computes and teams.\nThe examples and sample code provided in this workshop are intended to be consumed as instructional content. These will help you understand how various AWS services can be architected to build a solution while demonstrating best practices along the way. These examples are not intended for use in production environments.\n"
},
{
	"uri": "/0_prerquisites.html",
	"title": "Workshop Prerequisites",
	"tags": [],
	"description": "",
	"content": "Prerequisite Details For this workshop, participants will need an EKS cluster in any region, equipped with at least 3 worker nodes. Each node should have a minimum specification of 4 vCPUs and 16GB of memory.\nDetailed steps for deploying the EKS Cluster are provided in the following section.\n"
},
{
	"uri": "/0_prerquisites/eks.html",
	"title": "EKS Cluster deployment",
	"tags": [],
	"description": "",
	"content": "Setting Up Your Environment Variables Starting with setting up your environment variables is the most efficient approach. Please adjust these variables based on your specific AWS region:\nexport AWS_REGION=us-west-2 export EKS_VERSION=1.29 export CLUSTER_NAME=solo-io-gloo-mesh-workshop NUMBER_NODES=3 # Choose from compatible options - for example, the compute-optimized family with 8 vCPUs and 16.0 GiB of memory NODE_TYPE=\u0026#34;c7i.xlarge\u0026#34; Deploy Your Cluster with eksctl Use the following eksctl command to create your cluster. This command initiates the creation of CloudFormation stacks â€” one for the cluster and another for deploying the nodes:\neksctl create cluster --region $AWS_REGION \\ --name $CLUSTER_NAME \\ --nodes $NUMBER_NODES \\ --node-type $NODE_TYPE \\ --version=$EKS_VERSION Deployment will take 10-30 minutes and at the end your kubecontext will be pointing to this instance.\nNow you\u0026rsquo;re ready to dive into the workshop!\n"
},
{
	"uri": "/1_solo_workshop.html",
	"title": "Gloo Platform EKS Workshop",
	"tags": [],
	"description": "",
	"content": "Introduction In this workshop, we will deploy Gloo Platform on a single cluster and a subset of its features. This entire workshop can be completed in less than an hour.\nPrerequisites and Requirements One EKS cluster in any region with a minimum of 3 worker nodes of size 4vCPU and 16GB memory and above kubectl CLI configured to communicate with the EKS cluster helm binary is present to deploy demo application A basic understanding of containers and Kubernetes The examples and sample code provided in this workshop are intended to be consumed as instructional content. These will help you understand how various AWS services can be architected to build a solution while demonstrating best practices along the way. These examples are not intended for use in production environments.\n"
},
{
	"uri": "/1_solo_workshop/lab_1.html",
	"title": "Lab 1 - Deploy Gloo Platform",
	"tags": [],
	"description": "",
	"content": "Lab 1 - Deploy Gloo Platform Gloo Platform provides a management plane to interact with the service mesh and gateways in your environment. The management plane exposes a unified API that is multi-tenant and multi-cluster aware. It is responsible for taking your supplied configuration and updating the mesh and gateways in your clusters. Included in the management plane is a UI for policy and traffic observability.\nSet this environment variable to the Gloo license key.\nexport GLOO_PLATFORM_LICENSE_KEY=\u0026lt;licence_key\u0026gt; Install meshctl, the Gloo command line tool for bootstrapping Gloo Platform, registering clusters, describing configured resources, and more. Be sure to download version 2.4.4, which uses the latest Gloo Mesh installation values.\ncurl -sL https://run.solo.io/meshctl/install | GLOO_MESH_VERSION=v2.5.6 sh - export PATH=$HOME/.gloo-mesh/bin:$PATH Install Gloo Platform. This command uses profiles to install the control plane components, such as the management server and Prometheus server, and the data plane components, such as the agent, managed Istio service mesh, rate limit server, and external auth server, in your cluster.\nmeshctl install --profiles gloo-mesh-single,ratelimit,extauth \\ --set common.cluster=cluster-1 \\ --set licensing.glooMeshLicenseKey=$GLOO_PLATFORM_LICENSE_KEY \\ --set glooMgmtServer.extraEnvs.RELAY_TOKEN.value=\u0026#34;AWSWorkshopToken\u0026#34; \\ --set glooAgent.extraEnvs.RELAY_TOKEN.value=\u0026#34;AWSWorkshopToken\u0026#34; \\ --set demo.manageAddonNamespace=true Wait 2-3 minutes for all components to install. Use meshctl check to check the status.\nOnce everything is ready, view the Gloo Platform Dashboard.\nmeshctl dashboard As you might have noticed there is no Workspaces created yet. Let\u0026rsquo;s create a Global Workspace. In the case of this Lab, to simplify the deployment, include all services within the same workspace. This means that they all share the same service discovery policies and security. This is only recommended for the workshop to allow beginners learning Gloo Mesh.\nkubectl apply -f - \u0026lt;\u0026lt;EOF apiVersion: admin.gloo.solo.io/v2 kind: Workspace metadata: name: global-workspace namespace: gloo-mesh spec: workloadClusters: - name: \u0026#39;*\u0026#39; # all namespaces in all clusters namespaces: - name: \u0026#39;*\u0026#39; --- apiVersion: admin.gloo.solo.io/v2 kind: WorkspaceSettings metadata: name: global-settings namespace: gloo-mesh spec: exportTo: - workspaces: - name: global-workspace resources: - kind: SERVICE namespace: gloo-mesh-gateways EOF Wait for the Gloo Gateway Service to become ready and set its IP address to a variable for us to use later:\nexport GLOO_GATEWAY=$(kubectl -n gloo-mesh-gateways get svc istio-ingressgateway -o jsonpath=\u0026#39;{.status.loadBalancer.ingress[0].*}\u0026#39;) printf \u0026#34;\\n\\nGloo Gateway available at https://$GLOO_GATEWAY\\n\u0026#34; Note: No application will respond to this address\u0026hellip;yet!\nIn this Lab, we have successfully set up the foundational elements of the Gloo Platform. We\u0026rsquo;ve installed essential components like the Gloo command line tool, established the Gloo Platform, and created a Global Workspace. This setup paves the way for deploying actual applications and managing their traffic, which will be our focus in the next lab. Remember, the structures we\u0026rsquo;ve put in place here are crucial for the seamless operation of more complex service mesh architectures that we will explore.\nAs we transition to the next Lab, we will leverage this infrastructure to deploy and expose a sample application. This will not only demonstrate the practical application of our setup but also introduce us to the real-world scenarios of managing microservices traffic.\n"
},
{
	"uri": "/1_solo_workshop/lab_2.html",
	"title": "Lab 2 - Deploy &amp; Expose Online Boutique Sample Application",
	"tags": [],
	"description": "",
	"content": "Lab 2 - Deploy \u0026amp; Expose Online Boutique Sample Application Deploy the Online Boutique microservices to the online-boutique namespace.\nkubectl create namespace online-boutique kubectl label ns online-boutique istio-injection=enabled helm upgrade --install online-boutique \\ oci://us-central1-docker.pkg.dev/solo-test-236622/solo-demos/onlineboutique \\ --create-namespace \\ --namespace online-boutique To capture the traffic coming to the Gateway and route them to your applications, you need to use the VirtualGateway and RouteTable resources.\nVirtualGateway represents a logical gateway configuration served by Gateway workloads. It describes a set of ports that the virtual gateway listens to for incoming or outgoing HTTP/TCP connections, the type of protocol to use, SNI configuration, etc.\nRouteTable defines one or more hosts and a set of traffic route rules to handle traffic for these hosts. The traffic route rules can be delegated to other RouteTables based on one or more given hosts or specific paths. This allows you to create a hierarchy of routing configuration and dynamically attach policies at various levels.\nLet\u0026rsquo;s start by assuming the role of an Ops team. Configure the Gateway to listen on port 80 and create a generic RouteTable that further delegates the traffic routing to RouteTables in other namespaces.\nkubectl apply -f - \u0026lt;\u0026lt;EOF apiVersion: networking.gloo.solo.io/v2 kind: VirtualGateway metadata: name: ingress namespace: gloo-mesh-gateways spec: workloads: - selector: labels: app: istio-ingressgateway namespace: gloo-mesh-gateways listeners: - http: {} port: number: 80 allowedRouteTables: - host: \u0026#39;*\u0026#39; selector: namespace: gloo-mesh-gateways --- apiVersion: networking.gloo.solo.io/v2 kind: RouteTable metadata: name: ingress namespace: gloo-mesh-gateways spec: hosts: - \u0026#39;*\u0026#39; virtualGateways: - name: ingress namespace: gloo-mesh-gateways workloadSelectors: [] http: - name: application-ingress labels: ingress: all delegate: routeTables: - namespace: online-boutique EOF The Dev team can now write their own RouteTables in their own namespace. Create a RouteTable to send traffic that matches URI prefix: / to the frontend application.\nkubectl apply -f - \u0026lt;\u0026lt;EOF apiVersion: networking.gloo.solo.io/v2 kind: RouteTable metadata: name: frontend namespace: online-boutique spec: workloadSelectors: [] http: - matchers: - uri: prefix: / name: frontend labels: route: frontend forwardTo: destinations: - ref: name: frontend namespace: online-boutique port: number: 80 EOF Visit the online boutique application in your browser.\nexport GLOO_GATEWAY=$(kubectl -n gloo-mesh-gateways get svc istio-ingressgateway -o jsonpath=\u0026#39;{.status.loadBalancer.ingress[0].*}\u0026#39;) printf \u0026#34;\\n\\nGloo Gateway available at http://$GLOO_GATEWAY\\n\u0026#34; In this lab, we successfully deployed and exposed the Online Boutique Sample Application. By utilizing the VirtualGateway and RouteTable resources, we have established a foundational understanding of how to manage traffic in a microservices architecture. This knowledge is crucial for effectively routing workloads, which is the focus of our next lab.\n"
},
{
	"uri": "/1_solo_workshop/lab_3.html",
	"title": "Lab 3 - Routing workloads",
	"tags": [],
	"description": "",
	"content": "Lab 3 - Routing to other workloads Let\u0026rsquo;s see how easy it is to expose another application. This time, we will match on URI prefix: /products and send to the productcatalogservice application.\nkubectl apply -f - \u0026lt;\u0026lt;EOF apiVersion: networking.gloo.solo.io/v2 kind: RouteTable metadata: name: productcatalog namespace: online-boutique spec: weight: 100 workloadSelectors: [] http: - matchers: - uri: exact: /products - uri: prefix: /products name: products labels: route: products forwardTo: destinations: - ref: name: productcatalogservice namespace: online-boutique port: number: 3555 EOF Get products from the Product Catalog API.\ncurl $GLOO_GATEWAY/products Next, let\u0026rsquo;s route to an endpoint (http://httpbin.org) that is external to the cluster. ExternalService resource defines a service that exists outside of the mesh. ExternalService provides a mechanism to tell Gloo Platform about its existance and how it should be communicated with. Once an ExternalService is created, a RouteTable can be used to send traffic to it. In this example, we will send traffic on URI prefix: /httpbin to this external service.\nkubectl apply -f - \u0026lt;\u0026lt;EOF apiVersion: networking.gloo.solo.io/v2 kind: ExternalService metadata: name: httpbin namespace: online-boutique spec: hosts: - httpbin.org ports: - name: https number: 443 protocol: HTTPS clientsideTls: {} ### upgrade outbound call to HTTPS EOF Create a new RouteTable that will match on requests containing the prefix /httpbin and route it to the httpbin ExternalService. You may have also noticed that we are rewriting the path using pathRewrite: / because httpbin.org is listening for /get.\nkubectl apply -f - \u0026lt;\u0026lt;\u0026#39;EOF\u0026#39; apiVersion: networking.gloo.solo.io/v2 kind: RouteTable metadata: name: httpbin namespace: online-boutique spec: weight: 150 workloadSelectors: [] http: - matchers: - uri: prefix: /httpbin name: httpbin-all labels: route: httpbin forwardTo: pathRewrite: / destinations: - ref: name: httpbin port: number: 443 kind: EXTERNAL_SERVICE EOF Let\u0026rsquo;s test it.\ncurl -v $GLOO_GATEWAY/httpbin/get The expected results of the executed commands are illustrated in the screenshot below.\nThis lab has equipped us with practical knowledge on routing to various workloads, including external services. We\u0026rsquo;ve successfully exposed another application by matching URI prefixes and routing to services both within and outside our cluster. This lab has demonstrated the flexibility and power of the Gloo Platform in handling diverse routing scenarios, an essential skill in microservices architecture.\nAs we mastered routing to different workloads, we also gained insights into path rewriting and handling external services, setting a solid foundation for more advanced traffic management.\n"
},
{
	"uri": "/1_solo_workshop/lab_4.html",
	"title": "Lab 4 - AI Integration",
	"tags": [],
	"description": "",
	"content": "Lab 4 - AI Integration TODO: Text\nkubectl apply -f - \u0026lt;\u0026lt;EOF apiVersion: networking.gloo.solo.io/v2 kind: ExternalService metadata: name: huggingface-api namespace: online-boutique spec: hosts: - api-inference.huggingface.co ports: - name: https number: 443 protocol: HTTPS clientsideTls: {} EOF TODO: Text\nkubectl apply -f - \u0026lt;\u0026lt;EOF apiVersion: networking.gloo.solo.io/v2 kind: RouteTable metadata: name: direct-to-huggingface-routetable namespace: online-boutique spec: workloadSelectors: [] http: - name: demo-huggingface labels: route: huggingface matchers: - uri: prefix: /huggingface forwardTo: pathRewrite: /models/openai-community/gpt2 hostRewrite: api-inference.huggingface.co destinations: - kind: EXTERNAL_SERVICE ref: name: huggingface-api port: number: 443 EOF export HF_API_TOKEN=\u0026ldquo;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\u0026rdquo; curl https://api-inference.huggingface.co/models/openai-community/gpt2 -X POST -d \u0026lsquo;{\u0026ldquo;inputs\u0026rdquo;: \u0026ldquo;Write me a 30 second pitch on why I should use an API gateway in front of my LLM backends\u0026rdquo;}\u0026rsquo; -H \u0026lsquo;Content-Type: application/json\u0026rsquo; -H \u0026ldquo;Authorization: Bearer ${HF_API_TOKEN}\u0026rdquo;\ncurl http://$GLOO_GATEWAY/huggingface -X POST -d \u0026lsquo;{\u0026ldquo;inputs\u0026rdquo;: \u0026ldquo;Write me a 30 second pitch on why I should use an API gateway in front of my LLM backends\u0026rdquo;}\u0026rsquo; -H \u0026lsquo;Content-Type: application/json\u0026rsquo; -H \u0026ldquo;Authorization: Bearer ${HF_API_TOKEN}\u0026rdquo;\nTODO: Text\nkubectl apply -f - \u0026lt;\u0026lt;EOF EOF TODO: Text\nkubectl apply -f - \u0026lt;\u0026lt;EOF EOF TODO: Text\nkubectl apply -f - \u0026lt;\u0026lt;EOF apiVersion: networking.gloo.solo.io/v2 kind: ExternalService metadata: name: openai-api namespace: online-boutique spec: hosts: - api.openai.com ports: - name: https number: 443 protocol: HTTPS clientsideTls: {} EOF TODO: Text\nkubectl apply -f - \u0026lt;\u0026lt;EOF apiVersion: networking.gloo.solo.io/v2 kind: RouteTable metadata: name: direct-to-openai-routetable namespace: online-boutique spec: workloadSelectors: [] http: - name: catch-all labels: route: openai matchers: - uri: prefix: /openai forwardTo: pathRewrite: /v1/chat/completions hostRewrite: api.openai.com destinations: - kind: EXTERNAL_SERVICE ref: name: openai-api port: number: 443 EOF TODO: Text\ncurl https://$GLOO_GATEWAY/openai -H \u0026#34;Content-Type: application/json\u0026#34; -H \u0026#34;Authorization: Bearer $OPENAI_API_KEY\u0026#34; -d \u0026#39;{ \u0026#34;model\u0026#34;: \u0026#34;gpt-3.5-turbo\u0026#34;, \u0026#34;messages\u0026#34;: [ { \u0026#34;role\u0026#34;: \u0026#34;system\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;You are a solutions architect for kubernetes networking, skilled in explaining complex technical concepts surrounding API Gateway and LLM Models\u0026#34; }, { \u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;Write me a 30 second pitch on why I should use an API gateway in front of my LLM backends\u0026#34; } ] }\u0026#39; TODO: Text curl https://api.openai.com/v1/chat/completions -H \u0026#34;Content-Type: application/json\u0026#34; -H \u0026#34;Authorization: Bearer $OPENAI_API_KEY\u0026#34; -d \u0026#39;{ \u0026#34;model\u0026#34;: \u0026#34;gpt-3.5-turbo\u0026#34;, \u0026#34;messages\u0026#34;: [ { \u0026#34;role\u0026#34;: \u0026#34;system\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;You are a solutions architect for kubernetes networking, skilled in explaining complex technical concepts surrounding API Gateway and LLM Models\u0026#34; }, { \u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;Write me a 30 second pitch on why I should use an API gateway in front of my LLM backends\u0026#34; } ] }\u0026#39; export GLOO_GATEWAY=$(kubectl -n gloo-mesh-gateways get svc istio-ingressgateway -o jsonpath=\u0026rsquo;{.status.loadBalancer.ingress[0].*}\u0026rsquo;) printf \u0026ldquo;\\n\\nGloo Gateway available at http://$GLOO_GATEWAY\\n\u0026rdquo;\ncurl http://$GLOO_GATEWAY/openai -H \u0026ldquo;Content-Type: application/json\u0026rdquo; -H \u0026ldquo;Authorization: Bearer $OPENAI_API_KEY\u0026rdquo; -d \u0026lsquo;{ \u0026ldquo;model\u0026rdquo;: \u0026ldquo;gpt-3.5-turbo\u0026rdquo;, \u0026ldquo;messages\u0026rdquo;: [ { \u0026ldquo;role\u0026rdquo;: \u0026ldquo;system\u0026rdquo;, \u0026ldquo;content\u0026rdquo;: \u0026ldquo;You are a solutions architect for kubernetes networking, skilled in explaining complex technical concepts surrounding API Gateway and LLM Models\u0026rdquo; }, { \u0026ldquo;role\u0026rdquo;: \u0026ldquo;user\u0026rdquo;, \u0026ldquo;content\u0026rdquo;: \u0026ldquo;Write me a 30 second pitch on why I should use an API gateway in front of my LLM backends\u0026rdquo; } ] }\u0026rsquo;\n"
},
{
	"uri": "/1_solo_workshop/lab_5.html",
	"title": "Lab 5 - Authentication / API Key",
	"tags": [],
	"description": "",
	"content": "Lab 5 - Authentication / API Key API key authentication is one of the easiest forms of authentication to implement. Simply create a Kubernetes secret that contains the key and reference it from the ExtAuthPolicy. It is recommended to label the secrets so that multiple can be selected and more can be added later. You can select any header to validate against.\nCreate two secrets that Gloo will validate against. One with the api-key admin and the other developer.\nkubectl apply -f - \u0026lt;\u0026lt;EOF apiVersion: v1 kind: Secret metadata: name: solo-admin namespace: gloo-mesh-gateways labels: api-keyset: httpbin-users type: extauth.solo.io/apikey data: api-key: $(echo -n \u0026#34;admin\u0026#34; | base64) --- apiVersion: v1 kind: Secret metadata: name: solo-developer namespace: gloo-mesh-gateways labels: api-keyset: httpbin-users type: extauth.solo.io/apikey data: api-key: $(echo -n \u0026#34;developer\u0026#34; | base64) EOF Create the API key ExtAuthPolicy that will match header x-api-key values againt the secrets created above. The ExtAuthServer resource configures where authorization checks will be performed:\nkubectl apply -f - \u0026lt;\u0026lt;EOF apiVersion: admin.gloo.solo.io/v2 kind: ExtAuthServer metadata: name: ext-auth-server namespace: gloo-mesh-gateways spec: destinationServer: ref: cluster: cluster-1 name: ext-auth-service namespace: gloo-mesh port: name: grpc --- apiVersion: security.policy.gloo.solo.io/v2 kind: ExtAuthPolicy metadata: name: products-apikey namespace: gloo-mesh-gateways spec: applyToRoutes: - route: labels: route: products config: server: name: ext-auth-server namespace: gloo-mesh-gateways cluster: cluster-1 glooAuth: configs: - apiKeyAuth: headerName: x-api-key labelSelector: api-keyset: httpbin-users EOF Call httpbin without an api key and you will get a 401 unauthorized message:\ncurl -i http://$GLOO_GATEWAY/products Call httpbin with the developer api key x-api-key: developer:\ncurl -H \u0026#34;x-api-key: developer\u0026#34; http://$GLOO_GATEWAY/products Call httpbin with the admin api key x-api-key: admin:\ncurl -H \u0026#34;x-api-key: admin\u0026#34; http://$GLOO_GATEWAY/products The expected results of the executed commands are illustrated in the screenshot below:\nIn this lab, we\u0026rsquo;ve taken significant steps in enhancing the security of our application by implementing API key authentication. By creating Kubernetes secrets for different user roles and setting up the ExtAuthPolicy, we\u0026rsquo;ve established a reliable method to secure and manage access to our services. This lab has not only highlighted the ease of setting up basic authentication but also emphasized the importance of robust security practices in microservices architectures.\nAs we move forward, the concepts and skills we\u0026rsquo;ve acquired here will be crucial in understanding and implementing more comprehensive security strategies.\n```bash kubectl apply -f - \u0026lt;\u0026lt;'EOF' apiVersion: security.policy.gloo.solo.io/v2 kind: ExtAuthPolicy metadata: name: huggingface-apikey namespace: gloo-mesh-gateways spec: applyToRoutes: - route: labels: route: huggingface config: server: name: ext-auth-server namespace: gloo-mesh-gateways cluster: cluster-1 glooAuth: configs: - apiKeyAuth: headerName: api-key k8sSecretApikeyStorage: labelSelector: api-key: api-huggingface EOF ``` ```bash kubectl apply -f - \u0026lt;\u0026lt;'EOF' apiVersion: v1 kind: Secret metadata: name: api-huggingface-key labels: api-key: api-huggingface type: extauth.solo.io/apikey data: api-key: bXlzZWNyZXRrZXk= # Base64 encoded value \u0026quot;mysecretkey\u0026quot; EOF ``` ```bash curl http://$GLOO_GATEWAY/huggingface ``` ```bash curl -v -H \u0026quot;api-key: mysecretkey\u0026quot; http://$GLOO_GATEWAY/huggingface ``` ```bash kubectl patch secret api-huggingface-key \\ --type=json \\ -p='[{\u0026quot;op\u0026quot;: \u0026quot;add\u0026quot;, \u0026quot;path\u0026quot;: \u0026quot;/data/huggingface-api-key\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;'$(echo -n $HF_API_TOKEN | base64)'\u0026quot;}]' ``` ```bash kubectl patch extauthpolicy huggingface-apikey \\ -n gloo-mesh-gateways \\ --type=json \\ -p='[{\u0026quot;op\u0026quot;: \u0026quot;add\u0026quot;, \u0026quot;path\u0026quot;: \u0026quot;/spec/config/glooAuth/configs/0/apiKeyAuth/headersFromMetadataEntry\u0026quot;, \u0026quot;value\u0026quot;: {\u0026quot;x-api-key\u0026quot;: {\u0026quot;name\u0026quot;: \u0026quot;huggingface-api-key\u0026quot;}}}]' ``` ```bash kubectl apply -f - \u0026lt;\u0026lt;'EOF' apiVersion: trafficcontrol.policy.gloo.solo.io/v2 kind: TransformationPolicy metadata: name: huggingface-transformations spec: applyToRoutes: - route: labels: route: huggingface config: request: injaTemplate: headers: Authorization: text: 'Bearer {{ huggingface-api-key }}' extractors: huggingface-api-key: header: 'x-api-key' regex: '.*' EOF ``` ```bash curl http://$GLOO_GATEWAY/huggingface \\ -X POST \\ -d '{\u0026quot;inputs\u0026quot;: \u0026quot;Write me a 30 second pitch on why I should use an API gateway in front of my LLM backends\u0026quot;}' \\ -H 'Content-Type: application/json' \\ -H \u0026quot;api-key: mysecretkey\u0026quot; ``` "
},
{
	"uri": "/1_solo_workshop/lab_6.html",
	"title": "Lab 6 - AI API Key handling",
	"tags": [],
	"description": "",
	"content": "Lab 6 - AI API Key handling ```bash kubectl apply -f - \u0026lt;\u0026lt;'EOF' apiVersion: security.policy.gloo.solo.io/v2 kind: ExtAuthPolicy metadata: name: huggingface-apikey namespace: gloo-mesh-gateways spec: applyToRoutes: - route: labels: route: huggingface config: server: name: ext-auth-server namespace: gloo-mesh-gateways cluster: cluster-1 glooAuth: configs: - apiKeyAuth: headerName: api-key k8sSecretApikeyStorage: labelSelector: api-key: api-huggingface EOF ``` ```bash kubectl apply -f - \u0026lt;\u0026lt;'EOF' apiVersion: v1 kind: Secret metadata: name: api-huggingface-key labels: api-key: api-huggingface type: extauth.solo.io/apikey data: api-key: bXlzZWNyZXRrZXk= # Base64 encoded value \u0026quot;mysecretkey\u0026quot; EOF ``` ```bash curl http://$GLOO_GATEWAY/huggingface ``` ```bash curl -v -H \u0026quot;api-key: mysecretkey\u0026quot; http://$GLOO_GATEWAY/huggingface ``` ```bash kubectl patch secret api-huggingface-key \\ --type=json \\ -p='[{\u0026quot;op\u0026quot;: \u0026quot;add\u0026quot;, \u0026quot;path\u0026quot;: \u0026quot;/data/huggingface-api-key\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;'$(echo -n $HF_API_TOKEN | base64)'\u0026quot;}]' ``` ```bash kubectl patch extauthpolicy huggingface-apikey \\ -n gloo-mesh-gateways \\ --type=json \\ -p='[{\u0026quot;op\u0026quot;: \u0026quot;add\u0026quot;, \u0026quot;path\u0026quot;: \u0026quot;/spec/config/glooAuth/configs/0/apiKeyAuth/headersFromMetadataEntry\u0026quot;, \u0026quot;value\u0026quot;: {\u0026quot;x-api-key\u0026quot;: {\u0026quot;name\u0026quot;: \u0026quot;huggingface-api-key\u0026quot;}}}]' ``` ```bash kubectl apply -f - \u0026lt;\u0026lt;'EOF' apiVersion: trafficcontrol.policy.gloo.solo.io/v2 kind: TransformationPolicy metadata: name: huggingface-transformations spec: applyToRoutes: - route: labels: route: huggingface config: request: injaTemplate: headers: Authorization: text: 'Bearer {{ huggingface-api-key }}' extractors: huggingface-api-key: header: 'x-api-key' regex: '.*' EOF ``` ```bash curl http://$GLOO_GATEWAY/huggingface \\ -X POST \\ -d '{\u0026quot;inputs\u0026quot;: \u0026quot;Write me a 30 second pitch on why I should use an API gateway in front of my LLM backends\u0026quot;}' \\ -H 'Content-Type: application/json' \\ -H \u0026quot;api-key: mysecretkey\u0026quot; ``` "
},
{
	"uri": "/1_solo_workshop/lab_7.html",
	"title": "Lab 7 - Zero Trust",
	"tags": [],
	"description": "",
	"content": "Lab 7 - Zero Trust Let\u0026rsquo;s enforce a Zero Trust networking approach where all inbound traffic to any applications is denied by default.\nAdd a default deny-all policy to the backend-apis-team workspace:\ncat \u0026lt;\u0026lt; EOF | kubectl apply -f - apiVersion: security.policy.gloo.solo.io/v2 kind: AccessPolicy metadata: name: allow-nothing namespace: online-boutique spec: applyToWorkloads: - selector: namespace: online-boutique config: authn: tlsMode: STRICT authz: {} EOF Refresh the Online Boutique webpage (echo http://$GLOO_GATEWAY). You should see an error with message \u0026ldquo;RBAC: access denied\u0026rdquo;\nAdd AccessPolicy to explicitly allow traffic between the gateway and the frontend application:\nkubectl apply -f - \u0026lt;\u0026lt;EOF apiVersion: security.policy.gloo.solo.io/v2 kind: AccessPolicy metadata: name: frontend-api-access namespace: online-boutique spec: applyToDestinations: - selector: labels: app: frontend config: authz: allowedClients: - serviceAccountSelector: labels: app: istio-ingressgateway namespace: gloo-mesh-gateways EOF Add AccessPolicy to explicitly allow traffic between the microservices online-boutique workspace. As you can see, these policies can be very flexible.\nkubectl apply -f - \u0026lt;\u0026lt;EOF apiVersion: security.policy.gloo.solo.io/v2 kind: AccessPolicy metadata: name: in-namespace-access namespace: online-boutique spec: applyToDestinations: - selector: namespace: online-boutique config: authz: allowedClients: - serviceAccountSelector: namespace: online-boutique EOF Refresh the page (echo http://$GLOO_GATEWAY) again. You should get the store home page back.\nIn this lab, we effectively implemented a Zero Trust network security model, where we began by denying all inbound traffic by default. Through careful configuration of AccessPolicy rules, we selectively allowed necessary communication between the gateway, the frontend, and other microservices within the online-boutique workspace. This approach not only bolstered our network\u0026rsquo;s security but also demonstrated the practicality and flexibility of Zero Trust principles in a cloud-native ecosystem.\n"
},
{
	"uri": "/1_solo_workshop/lab_8.html",
	"title": "Lab 8 - Traffic Policies",
	"tags": [],
	"description": "",
	"content": "Lab 8 - Traffic Policies In this lab, we will implement intelligent routing rules for the applications in your cluster using Gloo traffic policies. These policies enable you to optimize responses to incoming requests and apply internal security and compliance standards to individual routes, destinations, or entire workloads. This will help you enforce your networking strategy throughout your microservices architecture.\nGloo Platform supports various policies to ensure network resiliency, traffic control, security, and observability for the microservices in your cluster. These can be applied to both gateway and workloads in the mesh, using Kubernetes labels and selectors that match RouteTables, VirtualDestinations, or workloads.\nExercise: Implementing and Measuring Traffic Delay Measure Baseline Response Time: Before applying any traffic policies, it\u0026rsquo;s important to establish a baseline for the current response time. Use the following curl command to measure this:\ncurl -o /dev/null -s -w \u0026#34;Time Connect: %{time_connect}s\\nTime Start Transfer: %{time_starttransfer}s\\nTotal Time: %{time_total}s\\n\u0026#34; http://$GLOO_GATEWAY Apply a Fault Injection Policy: Now, apply a simple fault injection policy to the frontend RouteTable using its label. This configuration will introduce a 3-second delay:\nkubectl apply -f - \u0026lt;\u0026lt;EOF apiVersion: resilience.policy.gloo.solo.io/v2 kind: FaultInjectionPolicy metadata: name: 3sec-fault-injection namespace: online-boutique spec: applyToRoutes: - route: labels: route: frontend config: delay: fixedDelay: 3s percentage: 100 EOF Measure the Introduced Delay: After applying the fault injection policy, use the same curl command to measure the response time again. The increase in \u0026lsquo;Time Start Transfer\u0026rsquo; and \u0026lsquo;Total Time\u0026rsquo; values will demonstrate the delay introduced by the Gloo Platform/Istio service mesh policy:\ncurl -o /dev/null -s -w \u0026#34;Time Connect: %{time_connect}s\\nTime Start Transfer: %{time_starttransfer}s\\nTotal Time: %{time_total}s\\n\u0026#34; http://$GLOO_GATEWAY The expected results of the executed commands are illustrated in the screenshot below:\nThis exercise will help you understand and quantify the impact of traffic policies in a microservices environment.\n"
},
{
	"uri": "/1_solo_workshop/summary.html",
	"title": "Workshop Summary",
	"tags": [],
	"description": "",
	"content": "Workshop Summary Throughout this workshop, we navigated a series of labs that built up our proficiency in managing and securing a microservices architecture with the Gloo Platform:\nStarting with the Basics: We initiated our journey by setting up the essential components of the Gloo Platform, laying a robust foundation.\nSecurity and Traffic Management: We delved into advanced topics like Zero Trust security and traffic policies, which are pivotal for modern cloud-native applications.\nHands-On Application and Troubleshooting: The practical application of these concepts not only enhanced our understanding but also equipped us with skills for troubleshooting and optimization.\nInsights with Gloo Dashboard: The workshop culminated with the Gloo Dashboard, offering a visual and intuitive approach to managing our microservices ecosystem.\nThe knowledge and skills acquired in this workshop are essential for anyone working with Kubernetes and service meshes in a cloud-native environment.\nThank you for participating in the Gloo Platform EKS Workshop. We hope this experience has been insightful and empowering, providing you with valuable tools and knowledge for your future endeavors in cloud-native technologies.\nReferences Review the following ways to get additional help, training, and other forms of support as you use Gloo Platform.\nTroubleshoot Issues Support and Slack "
},
{
	"uri": "/1_solo_workshop/lab_9.html",
	"title": "Lab 9 - Dashboard",
	"tags": [],
	"description": "",
	"content": "Lab 9 - Dashboard Let\u0026rsquo;s conclude this workshop by looking at the Gloo Dashboard again and exploring it\u0026rsquo;s various features\nLaunch the dashboard:\nmeshctl dashboard The homepage shows an at-a-glance look at the health of workspaces and clusters that make up your Gloo setup. In this workshop, we only used a single cluster and a single workspace, but Gloo Platform is intended to scale to multiple clusters and provide isolation between teams using Workspaces.\nThe \u0026lsquo;Solo\u0026rsquo; page within the \u0026lsquo;Resources\u0026rsquo; section provides a comprehensive view of various API objects, including Access and Traffic Policies, that we\u0026rsquo;ve defined during this workshop.\u0026quot; The \u0026lsquo;Istio\u0026rsquo; sub-section within the \u0026lsquo;Resources\u0026rsquo; section shows the Istio or Envoy configuration that was generated by Gloo. Review the configuration of translated Istio resources to help debug issues. The Graph page within the \u0026lsquo;Observability\u0026rsquo; section is used to visualize the network traffic that enters your cluster in a graph that maps out all the nodes by workspace, namespace, or cluster. This lab, as the final chapter of our Gloo Platform EKS Workshop, brought everything together by showcasing the Gloo Dashboard, an integral component for monitoring and managing the Gloo environment. Through this lab, you\u0026rsquo;ve had the opportunity to explore various dashboard features, giving you insights into the health of workspaces and clusters, the policies we\u0026rsquo;ve implemented throughout the workshop, and valuable debugging and network traffic visualization tools.\n"
},
{
	"uri": "/categories.html",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags.html",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]